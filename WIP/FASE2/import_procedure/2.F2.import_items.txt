// ========================================
// FASE 2 IMPORT CI ITEMS
// ========================================

CALL apoc.periodic.iterate(
  "LOAD CSV WITH HEADERS FROM 'file:///ciItems.csv' AS row RETURN row",
  "
  // 1. GESTIONE ITEMTYPE
  
  // Pulisci e determina valori finali
  WITH row,
       CASE 
         WHEN row.itemTypeId IS NOT NULL AND row.itemTypeId <> '' AND row.itemTypeId <> 'NULL'
         THEN toInteger(row.itemTypeId) 
         ELSE 999
       END AS finalTypeId,
       CASE 
         WHEN row.itemTypeName IS NOT NULL AND row.itemTypeName <> '' AND row.itemTypeName <> 'NULL'
         THEN row.itemTypeName 
         ELSE 'Generic_Item'
       END AS finalTypeName
  
  // Crea/aggiorna ItemType usando SOLO il nome come chiave primaria
  MERGE (itemType:ItemType {itemTypeName: finalTypeName})
  ON CREATE SET itemType.itemTypeId = finalTypeId,
                itemType.defaultLayer = '101'
  // Non settare itemTypeId in ON MATCH per evitare conflitti con constraint
  
  // 2. GESTIONE ACCOUNT
  
  WITH row, finalTypeId, finalTypeName,
       CASE 
         WHEN row.accountId IS NOT NULL AND row.accountId <> '' AND row.accountId <> 'NULL'
         THEN toInteger(row.accountId) 
         ELSE 9999
       END AS finalAccountId
  
  // Crea Account usando il nome come chiave primaria
  MERGE (account:Account {account_name: CASE 
    WHEN finalAccountId = 9999 THEN 'Default Account'
    ELSE 'Account_' + toString(finalAccountId)
  END})
  ON CREATE SET account.account_id = finalAccountId
  
  // 3. CREA CI ITEM
  
  MERGE (ci:CiItem {item_id: toInteger(row.item_id)})
  SET ci.itemTypeId = finalTypeId,
      ci.itemTypeName = finalTypeName,
      ci.name = row.name,
      ci.status = row.status,
      ci.accountId = finalAccountId,
      ci.importance = row.importance,
      ci.isLink = row.isLink,
      ci.fromElement = CASE WHEN row.fromElement IS NOT NULL AND row.fromElement <> '' THEN toInteger(row.fromElement) ELSE NULL END,
      ci.toElement = CASE WHEN row.toElement IS NOT NULL AND row.toElement <> '' THEN toInteger(row.toElement) ELSE NULL END,
      ci.latitude = CASE WHEN row.latitude IS NOT NULL AND row.latitude <> '' THEN toFloat(row.latitude) ELSE NULL END,
      ci.longitude = CASE WHEN row.longitude IS NOT NULL AND row.longitude <> '' THEN toFloat(row.longitude) ELSE NULL END,
      ci.itemIcon = row.itemIcon,
      ci.style = row.style,
      ci.url = row.url
  
  // 4. GESTIONE PROPRIETÀ DINAMICHE (VERSIONE CORRETTA CON NUMERI PROGRESSIVI)
  
  WITH ci, row,
       // Trova tutte le colonne propKey_N dove N è un numero
       [k IN keys(row) WHERE k STARTS WITH 'propKey_' AND k =~ 'propKey_[0-9]+' AND row[k] IS NOT NULL AND row[k] <> '' AND row[k] <> 'NULL'] AS dynKeys
  
  WITH ci, row, dynKeys,
       [k IN dynKeys | row[k]] AS keysList,
       // Estrai il numero da propKey_N e costruisci propVal_N
       [k IN dynKeys | row['propVal_' + substring(k, 8)]] AS valsList
  
  // Applica proprietà dinamiche usando apoc.create.setProperties se ci sono chiavi
  WITH ci, keysList, valsList
  CALL apoc.do.when(
    size(keysList) > 0,
    'CALL apoc.create.setProperties($ci, $keys, $vals) YIELD node RETURN node',
    'RETURN $ci AS node',
    {ci: ci, keys: keysList, vals: valsList}
  ) YIELD value
  
  RETURN ci.item_id AS processed_item
  ",
  {
    batchSize: 5000,
    parallel: false,
    concurrency: 3,
    retries: 5
  }
);